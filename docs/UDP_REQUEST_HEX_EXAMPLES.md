# UDP组播请求报文十六进制示例

本文档提供所有UDP组播请求报文的十六进制表示，用于Socket工具模拟测试。

## 报文头部格式（22字节）

所有请求报文都包含一个22字节的头部：

| 字节位置 | 长度 | 字段 | 说明 |
|---------|------|------|------|
| 0-1 | 2 | total length | 报文总长度（主机字节序，小端） |
| 2-3 | 2 | 0000H | 固定值 0x0000 |
| 4-7 | 4 | local IP | 本地IP地址（主机字节序，小端） |
| 8-11 | 4 | target IP | 目标组播地址（主机字节序，小端） |
| 12-15 | 4 | timestamp | 从今天00:00:00开始的毫秒数（主机字节序，小端） |
| 16 | 1 | 01H | 固定值 0x01 |
| 17 | 1 | Flag | 固定值 0xB2 |
| 18-19 | 2 | total length - 16 | 总长度减16（主机字节序，小端） |
| 20-21 | 2 | FFFFH | 固定值 0xFFFF |

**注意：** 所有多字节字段都使用**小端字节序**（主机字节序）。

## 示例值说明

以下示例使用的值：
- **组播地址**: 234.186.1.98 (0xEA 0xBA 0x01 0x62)
- **本地IP**: 192.168.1.100 (0xC0 0xA8 0x01 0x64)
- **请求ID**: 1 (0x01 0x00 0x00 0x00，小端)
- **时间戳**: 假设为 3600000 毫秒（1小时，0x00 0x36 0xEE 0x80，小端）

---

## 1. 资源监控请求 (ResourceMonitorRequest)

**命令码**: 0xF000  
**报文总长度**: 28 字节  
**结构**: header[22] + command[2] + requestId[4]

### 十六进制表示：

```
1C 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 0C 00 FF FF 00 F0 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     1C 00            total length = 28 (小端: 0x001C)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100 (小端: C0 A8 01 64)
8-11    62 01 BA EA      target IP = 234.186.1.98 (小端: EA BA 01 62)
12-15   80 EE 36 00      timestamp = 3600000 ms (小端: 00 36 EE 80)
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   0C 00            total length - 16 = 12 (小端: 0x000C)
20-21   FF FF            固定值 0xFFFF
22-23   00 F0            command = 0xF000 (小端)
24-27   01 00 00 00      requestId = 1 (小端)
```

### 完整十六进制（一行格式，用于复制）：

```
1C0000006401A8C06201BAEA80EE360001B20C00FFFF00F001000000
```

---

## 2. 任务查看请求 (TaskQueryRequest)

**命令码**: 0xF005  
**报文总长度**: 34 字节  
**结构**: header[22] + command[2] + requestId[4] + chassisNumber[2] + boardNumber[2] + taskIndex[2]

### 十六进制表示：

```
22 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 0C 00 FF FF 05 F0 01 00 00 00 01 00 01 00 01 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     22 00            total length = 34 (小端: 0x0022)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   0C 00            total length - 16 = 18 (小端: 0x0012)
20-21   FF FF            固定值 0xFFFF
22-23   05 F0            command = 0xF005 (小端)
24-27   01 00 00 00      requestId = 1
28-29   01 00            chassisNumber = 1 (小端)
30-31   01 00            boardNumber = 1 (小端)
32-33   01 00            taskIndex = 1 (小端)
```

### 完整十六进制（一行格式）：

```
220000006401A8C06201BAEA80EE360001B21200FFFF05F001000000010001000100
```

---

## 3. 任务启动请求 (TaskStartRequest)

**命令码**: 0xF003  
**报文总长度**: 32 字节  
**结构**: header[22] + command[2] + requestId[4] + workMode[2] + startStrategy[2]

### 十六进制表示：

```
20 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 10 00 FF FF 03 F0 01 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     20 00            total length = 32 (小端: 0x0020)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   10 00            total length - 16 = 16 (小端: 0x0010)
20-21   FF FF            固定值 0xFFFF
22-23   03 F0            command = 0xF003 (小端)
24-27   01 00 00 00      requestId = 1
28-29   01 00            workMode = 1 (模式1，小端)
30-31   00 00            startStrategy = 0 (先停止当前任务，再启动，小端)
```

### 完整十六进制（一行格式）：

```
200000006401A8C06201BAEA80EE360001B21000FFFF03F00100000001000000
```

**示例2：启动策略为1（先reset，再启动任务）**

```
200000006401A8C06201BAEA80EE360001B21000FFFF03F00100000001000100
```

---

## 4. 任务停止请求 (TaskStopRequest)

**命令码**: 0xF004  
**报文总长度**: 28 字节  
**结构**: header[22] + command[2] + requestId[4]

### 十六进制表示：

```
1C 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 0C 00 FF FF 04 F0 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     1C 00            total length = 28 (小端: 0x001C)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   0C 00            total length - 16 = 12 (小端: 0x000C)
20-21   FF FF            固定值 0xFFFF
22-23   04 F0            command = 0xF004 (小端)
24-27   01 00 00 00      requestId = 1
```

### 完整十六进制（一行格式）：

```
1C0000006401A8C06201BAEA80EE360001B20C00FFFF04F001000000
```

---

## 5. 机箱复位请求 (ChassisResetRequest)

**命令码**: 0xF001  
**报文总长度**: 136 字节  
**结构**: header[22] + command[2] + requestId[4] + resetFlags[108]

### 十六进制表示（前32字节，resetFlags部分用00填充示例）：

```
88 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 78 00 FF FF 01 F0 01 00 00 00
[后续108字节为resetFlags，每个字节表示一个板卡：0=不复位，1=需要复位]
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     88 00            total length = 136 (小端: 0x0088)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   78 00            total length - 16 = 120 (小端: 0x0078)
20-21   FF FF            固定值 0xFFFF
22-23   01 F0            command = 0xF001 (小端)
24-27   01 00 00 00      requestId = 1
28-135  [108字节]        resetFlags数组
                        位置28-39: 机箱1的12块板卡 (0-11)
                        位置40-51: 机箱2的12块板卡 (12-23)
                        ...
                        位置136-147: 机箱9的12块板卡 (96-107)
                        每个字节：0=不复位，1=需要复位
```

### 完整十六进制示例（复位机箱1的板卡1和板卡2）：

```
880000006401A8C06201BAEA80EE360001B27800FFFF01F00100000001010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

**说明**: 前28字节是header+command+requestId，后续108字节中：
- 第28字节（索引0）= 0x01，表示机箱1板卡1需要复位
- 第29字节（索引1）= 0x01，表示机箱1板卡2需要复位
- 其余字节 = 0x00，表示不复位

---

## 6. 机箱自检请求 (ChassisSelfCheckRequest)

**命令码**: 0xF002  
**报文总长度**: 42 字节  
**结构**: header[22] + command[2] + requestId[4] + chassisNumber[2] + checkFlags[12]

### 十六进制表示：

```
2A 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 1A 00 FF FF 02 F0 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     2A 00            total length = 42 (小端: 0x002A)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   1A 00            total length - 16 = 26 (小端: 0x001A)
20-21   FF FF            固定值 0xFFFF
22-23   02 F0            command = 0xF002 (小端)
24-27   01 00 00 00      requestId = 1
28-29   01 00            chassisNumber = 1 (小端)
30-41   [12字节]         checkFlags数组
                        每个字节表示一个板卡：0=自检，1=不需自检
                        示例：00 00 00 00 00 00 00 00 00 00 00 00
                        表示所有12块板卡都需要自检
```

### 完整十六进制（一行格式，自检机箱1的所有板卡）：

```
2A0000006401A8C06201BAEA80EE360001B21A00FFFF02F001000000010000000000000000000000000000
```

**示例2：只自检板卡1和板卡3（其他不需自检）**

```
2A0000006401A8C06201BAEA80EE360001B21A00FFFF02F001000000010000000100000000000000000000
```

说明：
- 第30字节（板卡1）= 0x00，需要自检
- 第31字节（板卡2）= 0x01，不需自检
- 第32字节（板卡3）= 0x00，需要自检
- 其余 = 0x01，不需自检

---

## 7. BMC查询请求 (BmcQueryRequest)

**命令码**: 0xF006  
**报文总长度**: 28 字节  
**结构**: header[22] + command[2] + requestId[4]

### 十六进制表示：

```
1C 00 00 00 64 01 A8 C0 62 01 BA EA 80 EE 36 00 01 B2 0C 00 FF FF 06 F0 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制）    说明
0-1     1C 00            total length = 28 (小端: 0x001C)
2-3     00 00            固定值 0x0000
4-7     64 01 A8 C0      local IP = 192.168.1.100
8-11    62 01 BA EA      target IP = 234.186.1.98
12-15   80 EE 36 00      timestamp = 3600000 ms
16      01               固定值 0x01
17      B2               固定值 0xB2
18-19   0C 00            total length - 16 = 12 (小端: 0x000C)
20-21   FF FF            固定值 0xFFFF
22-23   06 F0            command = 0xF006 (小端)
24-27   01 00 00 00      requestId = 1
```

### 完整十六进制（一行格式）：

```
1C0000006401A8C06201BAEA80EE360001B20C00FFFF06F001000000
```

---

## 使用说明

### 1. 在Socket工具中使用

1. **设置目标地址**：
   - 组播地址：`234.186.1.98`
   - 端口：`0x100A` (4106)

2. **发送数据**：
   - 将上述十六进制字符串（去掉空格）作为十六进制数据发送
   - 或者将十六进制转换为二进制数据发送

3. **修改参数**：
   - 根据实际需要修改 `requestId`、`chassisNumber`、`boardNumber` 等字段
   - 注意保持小端字节序

### 2. 字节序说明

所有多字节字段都使用**小端字节序**（Little-Endian）：
- `0x0001` 在小端中表示为 `01 00`
- `0x1234` 在小端中表示为 `34 12`
- IP地址 `192.168.1.100` = `0xC0A80164`，在小端中表示为 `64 01 A8 C0`

### 3. 时间戳计算

时间戳是从今天 00:00:00 开始的毫秒数。例如：
- 当前时间：2025-12-14 10:30:00
- 今天00:00:00：2025-12-14 00:00:00
- 时间差：10小时30分钟 = 37800000 毫秒
- 十六进制：0x0240E380
- 小端表示：`80 E3 40 02`

### 4. IP地址转换

IP地址转换为小端格式：
- `192.168.1.100` → `0xC0A80164` → 小端：`64 01 A8 C0`
- `234.186.1.98` → `0xEABA0162` → 小端：`62 01 BA EA`

### 5. 快速生成工具

可以使用Python脚本快速生成：

```python
import struct
import time

def ip_to_bytes(ip_str):
    """将IP地址转换为小端字节序的4字节"""
    parts = [int(x) for x in ip_str.split('.')]
    return bytes(parts)

def create_header(total_length, local_ip, target_ip, timestamp_ms):
    """创建22字节的UDP头部"""
    header = bytearray(22)
    # 0-1: total length
    struct.pack_into('<H', header, 0, total_length)
    # 2-3: 0000H
    # 已经是0，不需要设置
    # 4-7: local IP
    header[4:8] = ip_to_bytes(local_ip)
    # 8-11: target IP
    header[8:12] = ip_to_bytes(target_ip)
    # 12-15: timestamp
    struct.pack_into('<I', header, 12, timestamp_ms)
    # 16: 01H
    header[16] = 0x01
    # 17: B2H
    header[17] = 0xB2
    # 18-19: total length - 16
    struct.pack_into('<H', header, 18, total_length - 16)
    # 20-21: FFFFH
    struct.pack_into('<H', header, 20, 0xFFFF)
    return header

# 示例：生成资源监控请求
header = create_header(28, "192.168.1.100", "234.186.1.98", 3600000)
command = struct.pack('<H', 0xF000)  # 小端
request_id = struct.pack('<I', 1)    # 小端
packet = header + command + request_id
print(' '.join(f'{b:02X}' for b in packet))
```

---

## 总结

| 请求类型 | 命令码 | 总长度 | 关键字段 |
|---------|--------|--------|---------|
| 资源监控 | 0xF000 | 28 | requestId |
| 任务查看 | 0xF005 | 34 | requestId, chassisNumber, boardNumber, taskIndex |
| 任务启动 | 0xF003 | 32 | requestId, workMode, startStrategy |
| 任务停止 | 0xF004 | 28 | requestId |
| 机箱复位 | 0xF001 | 136 | requestId, resetFlags[108] |
| 机箱自检 | 0xF002 | 42 | requestId, chassisNumber, checkFlags[12] |
| BMC查询 | 0xF006 | 28 | requestId |

所有请求都发送到组播地址 `234.186.1.98:4106`。

---

## 8. 机箱操作响应 (OperationResponse) - TCP协议

**注意**：机箱复位、上电、下电操作使用**TCP协议**（不是UDP组播），通过TCP连接到目标机箱IP的33000端口。

### OperationModel 结构体格式

```cpp
struct OperationModel {
    char m_strFlag[8];      // 标识符，固定为 "ETHSWB"
    char m_strIp[16];       // 目标IP地址字符串
    char m_cmd[8];          // 命令字符串：RESET, POWOFF, POWON
    char m_slot[16];        // 槽位状态数组（16字节，支持12个槽位）
    uint32_t m_reqId;       // 请求ID（小端字节序）
};
```

**总长度**: 52 字节 (8 + 16 + 8 + 16 + 4)

### 槽位状态说明

- `m_slot[x] = 0` (0x00): 不操作或操作成功 (`NO_OPERATION_OR_SUCCESS`)
- `m_slot[x] = 1` (0x01): 请求操作或操作失败 (`REQUEST_OPERATION_OR_FAILED`)
- 索引对应关系：`m_slot[0]` = 槽位1, `m_slot[1]` = 槽位2, ..., `m_slot[11]` = 槽位12

### TCP请求报文示例

#### 8.1 机箱复位请求 (RESET)

**目标**: TCP连接到 `192.168.2.180:33000`  
**命令**: RESET  
**操作槽位**: 1, 2

### 十六进制表示：

```
45 54 48 53 57 42 00 00 31 39 32 2E 31 36 38 2E 32 2E 31 38 30 00 00 00 00 00 00 00 00
52 45 53 45 54 00 00 00 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制/ASCII）    说明
0-7     45 54 48 53 57 42 00 00  m_strFlag = "ETHSWB" + 2字节填充0
8-23    31 39 32 2E 31 36 38 2E   m_strIp = "192.168.2.180" + 填充0
        32 2E 31 38 30 00 00 00
        00 00 00 00
24-31   52 45 53 45 54 00 00 00  m_cmd = "RESET" + 3字节填充0
32-47   01 01 00 00 00 00 00 00  m_slot数组
        00 00 00 00 00 00 00 00  槽位1=0x01, 槽位2=0x01, 其余=0x00
48-51   01 00 00 00              m_reqId = 1 (小端)
```

### 完整十六进制（一行格式）：

```
45544853574200003139322E3136382E322E31383000000000000000005245534554000000010100000000000000000000000000000001000000
```

#### 8.2 机箱上电请求 (POWON)

**目标**: TCP连接到 `192.168.2.180:33000`  
**命令**: POWON  
**操作槽位**: 1, 3, 5

### 十六进制表示：

```
45 54 48 53 57 42 00 00 31 39 32 2E 31 36 38 2E 32 2E 31 38 30 00 00 00 00 00 00 00 00
50 4F 57 4F 4E 00 00 00 01 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制/ASCII）    说明
0-7     45 54 48 53 57 42 00 00  m_strFlag = "ETHSWB"
8-23    31 39 32 2E 31 36 38 2E   m_strIp = "192.168.2.180"
        32 2E 31 38 30 00 00 00
        00 00 00 00
24-31   50 4F 57 4F 4E 00 00 00  m_cmd = "POWON" + 3字节填充0
32-47   01 00 01 00 01 00 00 00  m_slot数组
        00 00 00 00 00 00 00 00  槽位1=0x01, 槽位3=0x01, 槽位5=0x01, 其余=0x00
48-51   01 00 00 00              m_reqId = 1 (小端)
```

### 完整十六进制（一行格式）：

```
45544853574200003139322E3136382E322E3138300000000000000000504F574F4E0000000100010001000000000000000000000000000001000000
```

#### 8.3 机箱下电请求 (POWOFF)

**目标**: TCP连接到 `192.168.2.180:33000`  
**命令**: POWOFF  
**操作槽位**: 2, 4

### 十六进制表示：

```
45 54 48 53 57 42 00 00 31 39 32 2E 31 36 38 2E 32 2E 31 38 30 00 00 00 00 00 00 00 00
50 4F 57 4F 46 46 00 00 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制/ASCII）    说明
0-7     45 54 48 53 57 42 00 00  m_strFlag = "ETHSWB"
8-23    31 39 32 2E 31 36 38 2E   m_strIp = "192.168.2.180"
        32 2E 31 38 30 00 00 00
        00 00 00 00
24-31   50 4F 57 4F 46 46 00 00  m_cmd = "POWOFF" + 2字节填充0
32-47   00 01 00 01 00 00 00 00  m_slot数组
        00 00 00 00 00 00 00 00  槽位2=0x01, 槽位4=0x01, 其余=0x00
48-51   01 00 00 00              m_reqId = 1 (小端)
```

### 完整十六进制（一行格式）：

```
45544853574200003139322E3136382E322E3138300000000000000000504F574F46460000000100010000000000000000000000000000000001000000
```

### TCP响应报文示例

服务器响应也是 `OperationModel` 结构，格式相同。区别在于：
- **请求中**：`m_slot[x] = 1` 表示要操作该槽位
- **响应中**：`m_slot[x] = 0` 表示操作成功，`m_slot[x] = 1` 表示操作失败

#### 8.4 复位成功响应示例

**场景**: 复位机箱1的板卡1和板卡2，全部成功

### 十六进制表示：

```
45 54 48 53 57 42 00 00 31 39 32 2E 31 36 38 2E 32 2E 31 38 30 00 00 00 00 00 00 00 00
52 45 53 45 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制/ASCII）    说明
0-7     45 54 48 53 57 42 00 00  m_strFlag = "ETHSWB"
8-23    31 39 32 2E 31 36 38 2E   m_strIp = "192.168.2.180"
        32 2E 31 38 30 00 00 00
        00 00 00 00
24-31   52 45 53 45 54 00 00 00  m_cmd = "RESET"
32-47   00 00 00 00 00 00 00 00  m_slot数组（响应）
        00 00 00 00 00 00 00 00  槽位1=0x00(成功), 槽位2=0x00(成功), 其余=0x00
48-51   01 00 00 00              m_reqId = 1 (与请求ID一致)
```

### 完整十六进制（一行格式）：

```
45544853574200003139322E3136382E322E31383000000000000000005245534554000000000000000000000000000000000000000000000000000001000000
```

#### 8.5 部分成功响应示例

**场景**: 复位机箱1的板卡1、2、3，板卡1和2成功，板卡3失败

### 十六进制表示：

```
45 54 48 53 57 42 00 00 31 39 32 2E 31 36 38 2E 32 2E 31 38 30 00 00 00 00 00 00 00 00
52 45 53 45 54 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00
```

### 字段解析：

```
位置    值（十六进制/ASCII）    说明
32-47   00 00 01 00 00 00 00 00  m_slot数组（响应）
        00 00 00 00 00 00 00 00  槽位1=0x00(成功), 槽位2=0x00(成功), 槽位3=0x01(失败)
```

### 完整十六进制（一行格式）：

```
45544853574200003139322E3136382E322E31383000000000000000005245534554000000000001000000000000000000000000000000000000000001000000
```

### 使用说明

1. **协议类型**: TCP（不是UDP）
2. **目标地址**: 机箱IP地址（如 `192.168.2.180`）
3. **目标端口**: 33000
4. **连接方式**: 
   - 建立TCP连接
   - 发送52字节的 `OperationModel` 结构
   - 在同一连接上接收52字节的响应
   - 关闭连接

5. **在Socket工具中使用**:
   - 使用TCP客户端模式
   - 连接到目标IP:33000
   - 发送上述十六进制数据（52字节）
   - 接收响应（52字节）

6. **命令类型**:
   - `RESET`: 复位板卡
   - `POWON`: 上电板卡
   - `POWOFF`: 下电板卡

7. **槽位数组索引**:
   - `m_slot[0]` = 槽位1
   - `m_slot[1]` = 槽位2
   - ...
   - `m_slot[11]` = 槽位12

8. **状态值**:
   - **请求中**: `0x01` = 要操作该槽位, `0x00` = 不操作
   - **响应中**: `0x00` = 操作成功, `0x01` = 操作失败

### Python生成示例

```python
import struct

def create_operation_model(cmd, target_ip, slot_numbers, req_id):
    """创建OperationModel结构（52字节）"""
    model = bytearray(52)
    
    # m_strFlag[8] = "ETHSWB" + 填充0
    flag = b"ETHSWB" + b"\x00" * 2
    model[0:8] = flag
    
    # m_strIp[16] = target_ip字符串 + 填充0
    ip_bytes = target_ip.encode('ascii') + b"\x00" * (16 - len(target_ip))
    model[8:24] = ip_bytes[:16]
    
    # m_cmd[8] = cmd字符串 + 填充0
    cmd_bytes = cmd.encode('ascii') + b"\x00" * (8 - len(cmd))
    model[24:32] = cmd_bytes[:8]
    
    # m_slot[16] - 初始化全0
    # 设置要操作的槽位为1
    for slot_num in slot_numbers:
        if 1 <= slot_num <= 12:
            model[32 + (slot_num - 1)] = 0x01
    
    # m_reqId[4] = req_id (小端)
    struct.pack_into('<I', model, 48, req_id)
    
    return bytes(model)

# 示例：复位机箱1的板卡1和2
request = create_operation_model("RESET", "192.168.2.180", [1, 2], 1)
print(' '.join(f'{b:02X}' for b in request))
```

---

## UDP请求报文格式错误处理说明

### 当前代码的错误处理机制

根据 `ResourceMonitorListener::ListenLoop()` 的实现，当接收到格式错误的UDP请求报文时，代码会按以下方式处理：

#### 1. 接收长度检查

**处理逻辑：**
- 如果 `recvLen <= 0`：直接忽略，继续监听下一个报文（**不记录日志**）
- 如果 `recvLen < 24`：直接忽略，继续监听（至少需要24字节才能读取命令码，header[22] + command[2]）

**代码位置：**
```cpp
// 至少需要24字节才能读取命令码（header[22] + command[2]）
if (recvLen > 0 && recvLen >= 24) {
    // 处理报文...
}
// 如果 recvLen < 24，直接跳过，不记录日志
```

**示例场景：**
- 接收到10字节的无效数据：静默忽略
- 接收到20字节的无效数据：静默忽略（不够24字节）

#### 2. 命令码检查

**处理逻辑：**
- 从 `buffer[22-23]` 读取命令码（2字节）
- 如果命令码不匹配任何已知命令码：**静默忽略**，继续监听（**不记录日志**）

**已知命令码：**
- `0xF000` - 资源监控请求
- `0xF005` - 任务查看请求
- `0xF003` - 任务启动请求
- `0xF004` - 任务停止请求
- `0xF001` - 机箱复位请求
- `0xF002` - 机箱自检请求
- `0xF006` - BMC查询请求

**代码位置：**
```cpp
uint16_t command;
memcpy(&command, buffer + 22, 2);

// 根据命令码检查对应的请求大小
if (command == m_cmdResourceMonitor && recvLen >= sizeof(ResourceMonitorRequest)) {
    // 处理资源监控请求...
}
else if (command == m_cmdTaskQuery && recvLen >= sizeof(TaskQueryRequest)) {
    // 处理任务查看请求...
}
// ... 其他命令码检查
// 如果命令码不匹配任何已知命令码，静默忽略
```

**示例场景：**
- 接收到命令码 `0xFFFF`：静默忽略，不记录日志
- 接收到命令码 `0x0000`：静默忽略，不记录日志

#### 3. 报文长度检查

**处理逻辑：**
- 每个命令码都有对应的最小长度要求（使用 `sizeof(RequestStruct)` 检查）
- 如果 `recvLen < sizeof(RequestStruct)`：**静默忽略**，继续监听（**不记录日志**）

**各请求的最小长度：**
- `ResourceMonitorRequest`: 28 字节
- `TaskQueryRequest`: 34 字节
- `TaskStartRequest`: 32 字节
- `TaskStopRequest`: 28 字节
- `ChassisResetRequest`: 136 字节
- `ChassisSelfCheckRequest`: 42 字节
- `BmcQueryRequest`: 28 字节

**代码位置：**
```cpp
if (command == m_cmdResourceMonitor && recvLen >= sizeof(ResourceMonitorRequest)) {
    // 处理请求...
}
// 如果 recvLen < sizeof(ResourceMonitorRequest)，静默忽略
```

**示例场景：**
- 命令码正确（0xF000），但长度只有25字节（需要28字节）：静默忽略
- 命令码正确（0xF001），但长度只有100字节（需要136字节）：静默忽略

#### 4. 报文头部格式检查

**当前实现：**
- **不检查**报文头部的格式（如total length、magic number等）
- 只要长度足够，命令码匹配，就会尝试处理
- 如果头部格式错误，可能导致解析错误或数据错误

**潜在问题：**
- 如果header中的total length字段与实际长度不匹配，不会检测
- 如果header中的magic number（0xFFFF）错误，不会检测
- 可能导致使用错误的数据进行后续处理

### 错误处理总结

| 错误类型 | 处理方式 | 日志级别 | 行为 |
|---------|---------|---------|------|
| recvLen <= 0 | 静默忽略 | 无日志 | 继续监听 |
| recvLen < 24 | 静默忽略 | 无日志 | 继续监听 |
| 命令码不匹配 | 静默忽略 | 无日志 | 继续监听 |
| 报文长度不足 | 静默忽略 | 无日志 | 继续监听 |
| 头部格式错误 | 不检查 | 无日志 | 可能错误处理 |

### 测试建议

在Socket工具中测试时，可以模拟以下错误场景：

1. **长度不足的报文**：
   - 发送10字节的无效数据
   - 发送20字节的无效数据（不够24字节）
   - **预期行为**：静默忽略，不记录日志

2. **命令码错误**：
   - 发送24字节的报文，但命令码为 `0xFFFF`
   - **预期行为**：静默忽略，不记录日志

3. **长度不匹配**：
   - 发送命令码为 `0xF000`，但长度只有25字节（需要28字节）
   - **预期行为**：静默忽略，不记录日志

4. **头部格式错误**：
   - 发送长度正确的报文，但header中的total length字段错误
   - **预期行为**：可能被处理，但可能导致数据错误（当前不检查）

### 注意事项

1. **静默失败**：所有格式错误都会静默忽略，不记录任何日志，这可能导致问题难以发现和调试。

2. **建议改进**：可以考虑添加日志记录，便于调试：
   ```cpp
   if (recvLen > 0 && recvLen < 24) {
       spdlog::debug("收到UDP数据包长度不足: {} 字节（至少需要24字节）", recvLen);
       continue;
   }
   
   // 如果命令码不匹配
   if (command != m_cmdResourceMonitor && command != m_cmdTaskQuery && ...) {
       spdlog::debug("收到未知命令码: 0x{:04X}", command);
       continue;
   }
   
   // 如果长度不匹配
   if (command == m_cmdResourceMonitor && recvLen < sizeof(ResourceMonitorRequest)) {
       spdlog::warn("资源监控请求长度不足: {} 字节（需要 {} 字节）", 
                    recvLen, sizeof(ResourceMonitorRequest));
       continue;
   }
   ```

3. **安全性考虑**：当前实现不验证报文头部的格式，恶意构造的报文可能被处理，建议添加头部格式验证。

4. **调试工具**：代码中已经包含了 `UdpDataPrinter::PrintReceivedDataSimple()` 调用，可以打印接收到的原始数据，便于调试格式错误。

